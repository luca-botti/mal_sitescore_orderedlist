import requests
import xmltodict
import json
import time
import random
import concurrent.futures
from bs4 import BeautifulSoup


FILE_NAME = "test"  # must be the name of the xml file generated by mal


# CONSTANTS (DO NOT CHANGE)
COSTANT = {
    "web_link_start": "https://myanimelist.net/anime/",
    "anime_attributes": [
        {
            "string": "ANIME NAME",
            "xml": "series_title",
            "json": "anime_name",
        }, # 0
        {
            "string": "ANIME ID",
            "xml": "series_animedb_id",
            "json": "anime_id",
        }, # 1
        {
            "string": "ANIME SCORE",
            "json": "anime_score",
            "search_key": "Score:",
            "sibling_distance": 3,
        }, # 2
        {
            "string": "ANIME RANK",
            "json": "anime_rank",
            "escape_list": ("#", "\n"),
            "search_key": "Ranked:",
            "sibling_distance": 2,
        }, # 3
        {
            "string": "ANIME POPULARITY",
            "json": "anime_popularity",
            "escape_list": ("#", "\n"),
            "search_key": "Popularity:",
            "sibling_distance": 2,
        }, # 4
        {
            "string": "ANIME MEMBERS",
            "json": "anime_members",
            "escape_list": (",", "\n"),
            "search_key": "Members:",
            "sibling_distance": 2,
        }, # 5
        {
            "string": "ANIME FAVORITES",
            "json": "anime_favorites",
            "escape_list": (",", "\n"),
            "search_key": "Favorites:",
            "sibling_distance": 2,
        }, # 6
        {
            "string": "ANIME TYPE",
            "xml": "series_type",
            "json": "anime_type",
            "search_key": "Type:",
            "sibling_distance": 3,
        }, # 7
        {
            "string": "ANIME EPISODES",
            "xml": "series_episodes",
            "json": "anime_episodes",
            "escape_list": ("\n"),
            "search_key": "Episodes:",
            "sibling_distance": 2,
        }, # 8
        {
            "string": "ANIME STATUS",
            "json": "anime_status",
            "escape_list": ("\n"),
            "search_key": "Status:",
            "sibling_distance": 2,
        }, # 9
        # {
        #     "string": "ANIME AIR START",
        #     "json": "anime_air_start",
        # }, # some ova has only one date
        # {
        #     "string": "ANIME AIR END",
        #     "json": "anime_air_end",
        # }, # some ova has only one date
        # {
        #     "string": "ANIME PREMIERED",
        #     "json": "anime_premiered",
        #     "search_key": "Premiered:",
        #     "sibling_distance": 3,
        # }, # not always present
        # {
        #     "string": "ANIME BROADCAST",
        #     "json": "anime_brodcast",
        #     "search_key": "Broadcast:",
        #     "sibling_distance": 2,
        # }, # not always present
        {
            "string": "ANIME PRODUCERS",
            "json": "anime_producers",
            "search_key": "Producers:",
            "first_list_index": 3,
            "list_jumper": 2,
        }, # 10
        {
            "string": "ANIME LICENSORS",
            "json": "anime_licensors",
            "search_key": "Licensors:",
            "sibling_distance": 3,
        }, # 11
        {
            "string": "ANIME STUDIOS",
            "json": "anime_studios",
            "search_key": "Studios:",
            "first_list_index": 3,
            "list_jumper": 2,
        }, # 12
        {
            "string": "ANIME SOURCE",
            "json": "anime_source",
            "search_key": "Source:",
            "sibling_distance": 2,
        }, # 13
        # {
        #     "string": "ANIME GENRES",
        #     "json": "anime_genres",
        #     "search_key": "Genres:",
        #     "first_list_index": 4,
        #     "list_jumper": 3,
        # }, # the search key needs to be different if therre is only one or more
        # {
        #     "string": "ANIME THEME",
        #     "json": "anime_theme",
        #     "search_key": "Themes:",
        #     "first_list_index": 4,
        #     "list_jumper": 3,
        # }, # the search key needs to be different if therre is only one or more
        # {
        #     "string": "ANIME DEMOGRAPHIC",
        #     "json": "anime_demographic",
        #     "sibling_distance": 3,
        #     "search_key": "Demographic:",
        # }, # not always present
        {
            "string": "ANIME DURATION",
            "json": "anime_duration",
            "sibling_distance": 2,
            "search_key": "Duration:",
        }, # 14
        {
            "string": "ANIME RATING",
            "json": "anime_rating",
            "sibling_distance": 2,
            "search_key": "Rating:",
        }, # 15
        {
            "string": "MY COMMENTS",
            "xml": "my_comments",
            "json": "my_comments",
        }, # 16
        {
            "string": "MY DISCUSS",
            "xml": "my_discuss",
            "json": "my_discuss",
        }, # 17
        {
            "string": "MY FINISH DATE",
            "xml": "my_finish_date",
            "json": "my_finish_date",
        }, # 18
        {
            "string": "MY ID",
            "xml": "my_id",
            "json": "my_id",
        }, # 19
        {
            "string": "MY PRYORITY",
            "xml": "my_priority",
            "json": "my_priority",
        }, # 20
        {
            "string": "MY RATED",
            "xml": "my_rated",
            "json": "my_rated",
        }, # 21
        {
            "string": "MY REWATCH VALUE",
            "xml": "my_rewatch_value",
            "json": "my_rewatch_value",
        }, # 22
        {
            "string": "MY REWATCHING",
            "xml": "my_rewatching",
            "json": "my_rewatching",
        }, # 23
        {
            "string": "MY REWATCHING EP",
            "xml": "my_rewatching_ep",
            "json": "my_rewatching_ep",
        }, # 24
        {
            "string": "MY SCORE",
            "xml": "my_score",
            "json": "my_score",
        }, # 25
        {
            "string": "MY SNS",
            "xml": "my_sns",
            "json": "my_sns",
        }, # 26
        {
            "string": "MY START DATE",
            "xml": "my_start_date",
            "json": "my_start_date",
        }, # 27
        {
            "string": "MY STATUS",
            "xml": "my_status",
            "json": "my_status",
        }, # 28
        {
            "string": "MY STORAGE",
            "xml": "my_storage",
            "json": "my_storage",
        }, # 29
        {
            "string": "MY STORAGE VALUE",
            "xml": "my_storage_value",
            "json": "my_storage_value",
        }, # 30
        {
            "string": "MY TAGS",
            "xml": "my_tags",
            "json": "my_tags",
        }, # 31
        {
            "string": "MY TIMES WATCHED",
            "xml": "my_times_watched",
            "json": "my_times_watched",
        }, # 32
        {
            "string": "MY WATCHED EPISODES",
            "xml": "my_watched_episodes",
            "json": "my_watched_episodes",
        }, # 33
        {
            "string": "UPDATE ON IMPORT",
            "xml": "update_on_import",
            "json": "update_on_import",
        }, # 34
    ],
}

NAME = 0
ID = 1
SCORE = 2
RANK = 3
TYPE = 7
STATUS = 9
# AIR_START
# AIR_END
# PREMIERED
PRODUCERS = 10
MY_END_DATE = 18
MY_PRIORITY = 20
MY_REWATCH_VALUE = 22
MY_SCORE = 25
MY_START_DATE = 27
MY_STORAGE = 29
WATCHED_EP = 33

rd = random.Random()


def escape(list, str, strip=True):
    for escape in list:
        str = str.replace(escape, "")

    if strip:
        return str.strip()
    else:
        return str


def extract(soup, attribute):

    try:

        if attribute.get("search_key") is None:
            var = attribute.get("string")
            if var == "ANIME NAME":
                return soup.find("h1", class_="title-name").contents[0].string
            elif var == "ANIME ID":
                return soup.find("input", attrs={"name": "aid"}).attrs["value"]
            # elif var == "ANIME AIR START":
            #     return escape(
            #         (","),
            #         soup.find("span", string="Aired:")
            #         .parent.contents[2]
            #         .string.split("to")[0],
            #     ).strip()
            # elif var == "ANIME AIR END":
            #     return escape(
            #         (","),
            #         soup.find("span", string="Aired:")
            #         .parent.contents[2]
            #         .string.split("to")[1],
            #     ).strip()
            else:
                if attribute.get("xml") is None:
                    return "ERROR"
                else:
                    return "USE XML"

        else:
            if attribute.get("first_list_index") is None:
                return escape(
                    attribute.get("escape_list", ()),
                    soup.find("span", string=attribute.get("search_key", ""))
                    .parent.contents[attribute.get("sibling_distance", 0)]
                    .string,
                )

            else:
                val = []
                temp = soup.find(
                    "span", string=attribute.get("search_key", "")
                ).parent.contents
                for i in range(
                    attribute.get("first_list_index", 0),
                    len(temp),
                    attribute.get("list_jumper", 1),
                ):
                    val.append(temp[i].string)

                return val
            
    except Exception as ex:
        print(soup.find("input", attrs={"name": "aid"}).attrs["value"])
        print("ERROR: " + attribute.get("string", "ERROR"))
        print("ERROR: " + str(ex))
        return "ERROR"


def update_score(a_list, anime, anti_block=True):
    anime_id = anime[COSTANT["anime_attributes"][ID]["xml"]]

    req = requests.get(COSTANT["web_link_start"] + anime_id, timeout=5)

    new = {}

    soup = BeautifulSoup(req.text, "html.parser")
    x = soup.find("input", attrs={"name": "aid"})
    if x is None:
        print("ROBOT PAGE ERROR")
        exit()

    for attribute in COSTANT["anime_attributes"]:
        new_key = attribute.get("json", "ERROR")
        if attribute.get("xml") is None:
            new[new_key] = extract(soup, attribute)
        else:
            new[new_key] = anime.get(attribute.get("xml", "ERROR"), "ERROR")

    a_list.append(new)

    if anti_block:
        time.sleep((rd.random() * 8) + 2) # delay between each request to avoid being blocked [2, 10]

    return


def gen_json_file():
    use_multithreading = True
    max_workers = 5
    use_anti_block = True # will add a delay between each request

    with open(FILE_NAME + ".xml", encoding="utf-8") as fd:
        doc = xmltodict.parse(fd.read())

        # print(json.dumps(doc, indent=4))

        # list of dictionary
        list_xml = doc.get("myanimelist").get("anime")

        if list_xml.__class__ is not list:
            list_xml = [list_xml]

        print("Readed " + str(len(list_xml)) + " Anime\n")

        anime_list = []

        if use_multithreading:
            with concurrent.futures.ThreadPoolExecutor( max_workers=max_workers ) as executor:
                for anime in list_xml:
                    executor.submit(update_score, anime_list, anime, use_anti_block)
                    if use_anti_block:
                        time.sleep(6.0 / max_workers)

                executor.shutdown(wait=True)

        else:
            for anime in list_xml:
                update_score(anime_list, anime, use_anti_block)

        a_dict = {}
        a_dict["list"] = anime_list

        # print(json.dumps(a_dict, indent=4))
        print("\nNumber of anime: " + str(len(anime_list)) + "\n")

        # save the list in a json file
        with open(FILE_NAME + ".json", "w", encoding="utf-8") as outfile:
            json.dump(a_dict, outfile, indent=4)


# def get_month(month):
#     if month == "Jan":
#         return 1
#     elif month == "Feb":
#         return 2
#     elif month == "Mar":
#         return 3
#     elif month == "Apr":
#         return 4
#     elif month == "May":
#         return 5
#     elif month == "Jun":
#         return 6
#     elif month == "Jul":
#         return 7
#     elif month == "Aug":
#         return 8
#     elif month == "Sep":
#         return 9
#     elif month == "Oct":
#         return 10
#     elif month == "Nov":
#         return 11
#     elif month == "Dec":
#         return 12
#     else:
#         return 0


def sanitize_paraeters (status, producers, max_score, min_score, sort_by, ascending):

    if status not in ["all", "Currently Airing", "Finished Airing", "Not yet aired"]:
        print("STATUS not valid, ignored")
        status = "all"

    producers = producers.strip()

    # if airing_dates_start_year < 1917 and airing_dates_start_year != 0:
    #     print("AIRING DATES START YEAR not valid, ignored")
    #     airing_dates_start_year = 0

    # if (
    #     airing_dates_start_month < 1 or airing_dates_start_month > 12
    # ) and airing_dates_start_month != 0:
    #     print("AIRING DATES START MONTH not valid, ignored")
    #     airing_dates_start_month = 0

    # if (
    #     airing_dates_start_day < 1 or airing_dates_start_day > 31
    # ) and airing_dates_start_day != 0:
    #     print("AIRING DATES START DAY not valid, ignored")
    #     airing_dates_start_day = 0

    # if airing_dates_end_year < 1917 and airing_dates_end_year != 0:
    #     print("AIRING DATES END YEAR not valid, ignored")
    #     airing_dates_end_year = 0

    # if (
    #     airing_dates_end_month < 1 or airing_dates_end_month > 12
    # ) and airing_dates_end_month != 0:
    #     print("AIRING DATES END MONTH not valid, ignored")
    #     airing_dates_end_month = 0

    # if (
    #     airing_dates_end_day < 1 or airing_dates_end_day > 31
    # ) and airing_dates_end_day != 0:
    #     print("AIRING DATES END DAY not valid, ignored")
    #     airing_dates_end_day = 0

    # if airing_dates_end_year < airing_dates_start_year:
    #     print("AIRING DATES END YEAR not valid, ignored")
    #     airing_dates_end_year = 0
    # elif (
    #     airing_dates_end_year == airing_dates_start_year
    #     and airing_dates_end_month < airing_dates_start_month
    # ):
    #     print("AIRING DATES END MONTH not valid, ignored")
    #     airing_dates_end_month = 0
    # elif (
    #     airing_dates_end_year == airing_dates_start_year
    #     and airing_dates_end_month == airing_dates_start_month
    #     and airing_dates_end_day < airing_dates_start_day
    # ):
    #     print("AIRING DATES END DAY not valid, ignored")
    #     airing_dates_end_day = 0

    # if season_year < 1917 and season_year != 0:
    #     print("SEASON YEAR not valid, ignored")
    #     season_year = 0

    # if season_season not in ["all", "Winter", "Spring", "Summer", "Fall"]:
    #     print("SEASON SEASON not valid, ignored")
    #     season_season = 0

    if sort_by not in [
        "deact",
        "status",
        "score",
        "my-score",
        "title",
        "type",
        "watched-ep",
        "rating",
        "my-rating",
        "my-start-date",
        "my-end-date",
        # "start-date",
        # "end-date",
        "last-updated",
        "rewatch-value",
        "priority",
        "storage",
    ]:
        print("SORT BY not valid, ignored")
        sort_by = "deact"

    if ascending not in [True, False]:
        print("ASCENDING not valid, setted to false")
        ascending = False

    if (max_score < 0 or max_score > 10) and max_score != -1:
        print("MAX SCORE not valid, ignored")
        max_score = -1

    if (min_score < 0 or min_score > 10) and min_score != -1:
        print("MIN SCORE not valid, ignored")
        min_score = -1
    
    if max_score != -1 and min_score != -1 and max_score < min_score:
        print("MAX SCORE not valid, ignored")
        max_score = -1

    return (status, producers, max_score, min_score, sort_by, ascending)


def get_dict_key (string):
    if string == "status":
        code = STATUS
    elif string == "score":
        code = SCORE
    elif string == "my-score":
        code = MY_SCORE
    elif string == "title":
        code = NAME
    elif string == "type":
        code = TYPE
    elif string == "watched-ep":
        code = WATCHED_EP
    elif string == "rating":
        code = RANK
    elif string == "my-rating":
        code = MY_SCORE
    elif string == "my-start-date":
        code = MY_START_DATE
    elif string == "my-end-date":
        code = MY_END_DATE
    # elif string == "start-date":
    #     code = AIR_START
    # elif string == "end-date":
    #     code = AIR_END
    elif string == "rewatch-value":
        code = MY_REWATCH_VALUE
    elif string == "priority":
        code = MY_PRIORITY
    elif string == "storage":
        code = MY_STORAGE
    else:
        return None

    return code


def read_json_file():
    # filters
    status = "all"  # "all", "Currently Airing", "Finished Airing", "Not yet aired"
    producers = "all"  # all, or use the exact name from mal

    # dates from 1917-01-01 to today, 0 don't care
    # airing_dates_start_year = 0  # >=1917, 0 don't care
    # airing_dates_start_month = 0  # [1, 12], 0 don't care
    # airing_dates_start_day = 0  # [1, 31], 0 don't care
    # airing_dates_end_year = 0  # >=1917, 0 don't care
    # airing_dates_end_month = 0  # [1, 12], 0 don't care
    # airing_dates_end_day = 0  # [1, 31], 0 don't care
    # season_year = 0  # >=1917, 0 don't care
    # season_season = "all"  # all, Winter, Spring, Summer, Fall

    max_score = -1  # [0, 10], -1 don't care
    min_score = -1  # [0, 10], -1 don't care

    # sorting
    sort_by = "score"  # deact, status, score, my-score, title, type, watched-ep, rating, my-rating, my-start-date, my-end-date, rewatch-value, priority, storage
    ascending = False  # True, False

    (status, producers, max_score, min_score, sort_by, ascending) = sanitize_paraeters(status, producers, max_score, min_score, sort_by, ascending)

    with open(FILE_NAME + ".json", "r", encoding="utf-8") as input:
        anime_list = json.load(input).get("list", [])

        print("\nReaded " + str(len(anime_list)) + " Anime from file\n")

        filtered_list = []

        # air_start_label = COSTANT.get("anime_attributes")[AIR_START].get("json")
        # air_end_label = COSTANT.get("anime_attributes")[AIR_END].get("json")
        # season_label = COSTANT.get("anime_attributes")[PREMIERED].get("json")
        status_label = COSTANT.get("anime_attributes")[STATUS].get("json")
        producers_label = COSTANT.get("anime_attributes")[PRODUCERS].get("json")
        score_label = COSTANT.get("anime_attributes")[SCORE].get("json")

        for anime in anime_list:

            # if anime.get(status_label, "") == "Not yet aired":
            #     air_s_y = 0
            #     air_s_m = 0
            #     air_s_d = 0
            #     air_e_d = 9999
            #     air_e_m = 13
            #     air_e_y = 32
            # else:
            #     air_s_y = int(anime.get(air_start_label, "").split()[2])
            #     air_s_m = get_month(anime.get(air_start_label, "").split()[0])
            #     air_s_d = int(anime.get(air_start_label, "").split()[1])
            #     air_e_y = int(anime.get(air_end_label, "").split()[2])
            #     air_e_m = get_month(anime.get(air_end_label, "").split()[0])
            #     air_e_d = int(anime.get(air_end_label, "").split()[1])
            
            # season_y = int(anime.get(season_label, "").split()[1])
            # season_s = anime.get(season_label, "").split()[0]

            if status == "all" or status == anime.get(status_label, ""):
                if producers == "all" or producers in anime.get( producers_label, [] ):
                    # if (airing_dates_start_year == 0 or air_s_y >= airing_dates_start_year):
                    #     if (airing_dates_start_month == 0 or air_s_m >= airing_dates_start_month):
                    #         if (airing_dates_start_day == 0 or air_s_d >= airing_dates_start_day):
                    #             if (airing_dates_end_year == 0 or air_e_y <= airing_dates_end_year):
                    #                 if (airing_dates_end_month == 0 or air_e_m <= airing_dates_end_month):
                    #                     if (airing_dates_end_day == 0 or air_e_d <= airing_dates_end_day):
                    #                         if (season_year == 0 or season_y == season_year):
                    #                             if (season_season == "all" or season_s == season_season):
                                                    score = anime.get(score_label, "")
                                                    if score == "N/A" and max_score == -1 and min_score == -1:
                                                        filtered_list.append(anime)
                                                        continue
                                                    else:
                                                        score = float(score)
                                                        if (max_score == -1 or score <= max_score):
                                                            if (min_score == -1 or score >= min_score):
                                                                filtered_list.append(anime)

        if not filtered_list:
            print("No anime found")
            return
        
        if sort_by != "deact":

            # if sort_by == "start-date" or sort_by == "end-date" or sort_by == "my-start-date" or sort_by == "my-end-date":
            #     filtered_list.sort(key=lambda x: x.get(COSTANT.get('anime_attributes')[get_dict_key(sort_by)].get('json')).split()[1], reverse=not ascending)
            #     filtered_list.sort(key=lambda x: get_month(x.get(COSTANT.get('anime_attributes')[get_dict_key(sort_by)].get('json')).split()[0]), reverse=not ascending)
            #     filtered_list.sort(key=lambda x: int(x.get(COSTANT.get('anime_attributes')[get_dict_key(sort_by)].get('json')).split()[2]), reverse=not ascending)
            # else:
            #     filtered_list.sort(key=lambda x: x.get(COSTANT.get('anime_attributes')[get_dict_key(sort_by)].get('json')), reverse=not ascending)
            filtered_list.sort(key=lambda x: x.get(COSTANT.get('anime_attributes')[get_dict_key(sort_by)].get('json')), reverse=not ascending)

            for anime in filtered_list:
                print(f"{anime.get(COSTANT.get('anime_attributes')[NAME].get('json'))} - {anime.get(COSTANT.get('anime_attributes')[get_dict_key(sort_by)].get('json'))}")
        
        else:
            for anime in filtered_list:
                print(f"{anime.get(COSTANT.get('anime_attributes')[NAME].get('json'))} - {anime.get(COSTANT.get('anime_attributes')[SCORE].get('json'))}")
        


if __name__ == "__main__":
    gen_json_file()
    read_json_file()
